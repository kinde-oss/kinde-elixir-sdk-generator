defmodule KindeClientSDK do
  @moduledoc """
  Kinde Client supporting `client_credentials`, `authorization_code` and `pkce` OAuth2 methods,
  providing authentication functionalities to your Kinde business.

  ## Configuration

  ### API Keys

  You can set your keys in your application configuration. Use `config/config.exs`.
  For example:

      config :kinde_management_api,
        backend_client_id: "test_x1y2z3a1",
        frontend_client_id: "test_a1b2c3d4",
        client_secret: "test_112233",
        redirect_url: "http://text.com/callback",
        domain: "https://test.kinde.com",
        logout_redirect_url: "http://text.com/logout"

  Optionally, you can also set `scope` as well.
      config :kinde_management_api,
        scope: "email"

  You can also use `System.get_env/1` to retrieve the API key from
  an environment variables. For example:

  config :kinde_management_api,
        backend_client_id: System.get_env("KINDE_BACKEND_CLIENT_ID")

  ## Usage

  Initialize your client like this:

      {conn, client} =
        KindeClientSDK.init(
          conn,
          Application.get_env(:kinde_management_api, :domain),
          Application.get_env(:kinde_management_api, :redirect_url),
          Application.get_env(:kinde_management_api, :backend_client_id),
          Application.get_env(:kinde_management_api, :client_secret),
          :client_credentials,
          Application.get_env(:kinde_management_api, :logout_redirect_url)
        )

  `conn` will be phoenix connection here here. Now, you can use other implemented client functions,
  like `login` and `get_token`.

  ### ETS Cache

  KindeClientSDK implements persistant ETS cache for storing the client data and authenticating
  variables.

  You may call your created client like this:

        pid = Conn.get_session(conn, :kinde_cache_pid)
        GenServer.call(pid, {:get_kinde_data, :kinde_client})

  ### Tokens

  We can use Kinde cache to get the tokens generated by `login` and `get_token` functions.

        pid = Conn.get_session(conn, :kinde_cache_pid)
        GenServer.call(pid, {:get_kinde_data, :kinde_login_time_stamp})
        GenServer.call(pid, {:get_kinde_data, :kinde_access_token})
        GenServer.call(pid, {:get_kinde_data, :kinde_id_token})
        GenServer.call(pid, {:get_kinde_data, :kinde_expires_in})
        GenServer.call(pid, {:get_kinde_data, :kinde_token})
        GenServer.call(pid, {:get_kinde_data, :kinde_user})
  """
  alias KindeManagementAPI.SDK.AuthorizationCode
  alias KindeManagementAPI.SDK.ClientCredentials
  alias KindeManagementAPI.SDK.Utils
  alias KindeManagementAPI.SDK.Pkce
  alias KindeManagementAPI.KindeCache
  alias Plug.Conn
  use Tesla

  @authorizationEndPoint "/oauth2/auth"
  @tokenEndPoint "/oauth2/token"
  @logoutEndPoint "/logout"

  @enforce_keys [
    :cache_pid,
    :domain,
    :redirect_uri,
    :client_secret,
    :client_id,
    :grant_type,
    :logout_endpoint
  ]
  defstruct [
    :cache_pid,
    :domain,
    :redirect_uri,
    :logout_redirect_uri,
    :client_id,
    :client_secret,
    :authorization_endpoint,
    :token_endpoint,
    :logout_endpoint,
    :grant_type,
    :auth_status,
    :additional_params,
    :scopes
  ]

  @doc """
  Used for initializing the Kinde client which will be then used other implemented client functions,
  like `login` and `get_token`.

  Initialize your client like this:

      {conn, client} =
        KindeClientSDK.init(
          conn,
          Application.get_env(:kinde_management_api, :domain),
          Application.get_env(:kinde_management_api, :redirect_url),
          Application.get_env(:kinde_management_api, :backend_client_id),
          Application.get_env(:kinde_management_api, :client_secret),
          :client_credentials,
          Application.get_env(:kinde_management_api, :logout_redirect_url)
        )

  `conn` will be phoenix connection here here.

  `scopes` is an optional and defaults to `"openid profile email offline"`. Scopes can be defined as string.

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.

  Throws for invalid `domain`, `redirect_uri` and `additional_params`.
  """
  @spec init(Plug.Conn.t(), binary, binary, any, any, any, any, binary, map) ::
          {Plug.Conn.t(),
           %KindeClientSDK{
             additional_params: map,
             auth_status: :unauthenticated,
             authorization_endpoint: <<_::64, _::_*8>>,
             cache_pid: pid,
             client_id: any,
             client_secret: any,
             domain: binary,
             grant_type: any,
             logout_endpoint: <<_::56, _::_*8>>,
             logout_redirect_uri: any,
             redirect_uri: binary,
             scopes: any,
             token_endpoint: <<_::64, _::_*8>>
           }}
  def init(
        conn,
        domain,
        redirect_uri,
        client_id,
        client_secret,
        grant_type,
        logout_redirect_uri,
        scopes \\ "openid profile email offline",
        additional_params \\ %{}
      ) do
    if !Utils.validate_url(domain) do
      throw("Please provide valid domain")
    end

    if !Utils.validate_url(redirect_uri) do
      throw("Please provide valid redirect_uri")
    end

    {:ok, pid} = KindeCache.start_link()
    conn = Conn.put_session(conn, :kinde_cache_pid, pid)

    client = %__MODULE__{
      cache_pid: pid,
      domain: domain,
      redirect_uri: redirect_uri,
      client_secret: client_secret,
      client_id: client_id,
      grant_type: grant_type,
      additional_params: Utils.check_additional_params(additional_params),
      logout_redirect_uri: logout_redirect_uri,
      scopes: scopes,
      authorization_endpoint: "#{domain}#{@authorizationEndPoint}",
      token_endpoint: "#{domain}#{@tokenEndPoint}",
      logout_endpoint: "#{domain}#{@logoutEndPoint}",
      auth_status: :unauthenticated
    }

    GenServer.cast(pid, {:add_kinde_data, {:kinde_client, client}})

    {conn, client}
  end

  @doc """
  Login function for KindeClient. If grant type is `:client_credentials`, then access token will be generated
  and stored to KindeCache. For other grant types, returned `conn` will redirect to the your Kinde business login page.

  Your callback function will call `get_token` function to get the authenticated user's token.

  ### Usage

        conn = KindeClientSDK.login(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.

  Throws for invalid `grant_type`.
  """
  @spec login(
          Plug.Conn.t(),
          %KindeClientSDK{
            additional_params: map,
            auth_status: atom,
            authorization_endpoint: <<_::64, _::_*8>>,
            cache_pid: pid,
            client_id: any,
            client_secret: any,
            domain: binary,
            grant_type: any,
            logout_endpoint: <<_::56, _::_*8>>,
            logout_redirect_uri: any,
            redirect_uri: binary,
            scopes: any,
            token_endpoint: <<_::64, _::_*8>>
          },
          map
        ) :: any
  def login(conn, client, additional_params \\ %{}) do
    clean_session(client.cache_pid)
    client = update_auth_status(client, :authenticating)

    case client.grant_type do
      :client_credentials ->
        ClientCredentials.login(conn, client, additional_params)

      :authorization_code ->
        AuthorizationCode.login(conn, client, additional_params)

      :authorization_code_flow_pkce ->
        Pkce.login(conn, client, :login, additional_params)

      _ ->
        update_auth_status(client, :unauthenticated)
        throw("Please provide correct grant_type")
    end
  end

  @doc """
  Register function for your KindeClient. Returing `conn` will redirect to the your Kinde business registration page.

  ### Usage

        conn = KindeClientSDK.register(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.
  """
  @spec register(
          Plug.Conn.t(),
          %KindeClientSDK{
            additional_params: map,
            auth_status: atom,
            authorization_endpoint: <<_::64, _::_*8>>,
            cache_pid: pid,
            client_id: any,
            client_secret: any,
            domain: binary,
            grant_type: any,
            logout_endpoint: <<_::56, _::_*8>>,
            logout_redirect_uri: any,
            redirect_uri: binary,
            scopes: any,
            token_endpoint: <<_::64, _::_*8>>
          },
          map
        ) :: Plug.Conn.t()
  def register(conn, client, additional_params \\ %{}) do
    client = update_auth_status(client, :authenticating)
    client = %{client | grant_type: :authorization_code}
    Pkce.login(conn, client, :registration, additional_params)
  end

  @doc """
  The function allows you to create organization. Similar to register, the returing `conn` will redirect
  to the your Kinde business registration page.

  ### Usage

        conn = KindeClientSDK.create_org(conn, client)

  `additional_params` is an optional and defaults to `%{}`. It accepts `:audience`, `:org_code` and
  `:org_name` keys in the map with string as values.
  """
  @spec create_org(
          Plug.Conn.t(),
          %KindeClientSDK{
            additional_params: map,
            auth_status: atom,
            authorization_endpoint: <<_::64, _::_*8>>,
            cache_pid: pid,
            client_id: any,
            client_secret: any,
            domain: binary,
            grant_type: any,
            logout_endpoint: <<_::56, _::_*8>>,
            logout_redirect_uri: any,
            redirect_uri: binary,
            scopes: any,
            token_endpoint: <<_::64, _::_*8>>
          },
          map
        ) :: Plug.Conn.t()
  def create_org(conn, client, additional_params \\ %{}) do
    additional_params = Map.put(additional_params, :is_create_org, "true")
    register(conn, client, additional_params)
  end

  @doc """
  Fetches the tokens for your KindeClient. The tokens can be obtained through Kinde cache afterwards.

  ### Usage

        {conn, client} = KindeClientSDK.get_token(conn)

  Get the tokens like this:

        pid = Conn.get_session(conn, :kinde_cache_pid)
        GenServer.call(pid, {:get_kinde_data, :kinde_access_token})
  """
  @spec get_token(Plug.Conn.t()) ::
          {Plug.Conn.t(),
           %KindeClientSDK{
             additional_params: map,
             auth_status: atom,
             authorization_endpoint: <<_::64, _::_*8>>,
             cache_pid: pid,
             client_id: any,
             client_secret: any,
             domain: binary,
             grant_type: any,
             logout_endpoint: <<_::56, _::_*8>>,
             logout_redirect_uri: any,
             redirect_uri: binary,
             scopes: any,
             token_endpoint: <<_::64, _::_*8>>
           }}
  def get_token(conn) do
    pid = Conn.get_session(conn, :kinde_cache_pid)
    [kinde_client: client] = GenServer.call(pid, {:get_kinde_data, :kinde_client})
    do_get_token(conn, client.grant_type)
  end

  defp do_get_token(conn, :client_credentials) do
    pid = Conn.get_session(conn, :kinde_cache_pid)
    [kinde_client: client] = GenServer.call(pid, {:get_kinde_data, :kinde_client})

    conn = ClientCredentials.login(conn, client)
    [kinde_client: client] = GenServer.call(pid, {:get_kinde_data, :kinde_client})
    {conn, client}
  end

  defp do_get_token(conn, grant_type)
       when grant_type in [:authorization_code, :authorization_code_flow_pkce] do
    pid = Conn.get_session(conn, :kinde_cache_pid)
    [kinde_client: client] = GenServer.call(pid, {:get_kinde_data, :kinde_client})

    new_grant_type = get_grant_type(client.grant_type)

    form_params = %{
      client_id: client.client_id,
      client_secret: client.client_secret,
      grant_type: new_grant_type,
      redirect_uri: client.redirect_uri,
      response_type: :code
    }

    connection = Conn.fetch_query_params(conn)
    params = connection.query_params
    state = params["state"]
    check_state_authentication(client.cache_pid, state)

    error = params["error"]

    if !is_nil(error) do
      error_description = params["error_description"]
      message = if !is_nil(error_description), do: error_description, else: error
      throw(message)
    end

    authorization_code = params["code"]
    if is_nil(authorization_code), do: throw("Not found code param")
    form_params = Map.put(form_params, :code, authorization_code)

    code_verifier =
      case GenServer.call(client.cache_pid, {:get_kinde_data, :kinde_oauth_code_verifier}) do
        [] -> nil
        [kinde_oauth_code_verifier: data] -> data
      end

    form_params =
      if !is_nil(code_verifier) do
        Map.put(form_params, :code_verifier, code_verifier)
      else
        if client.grant_type == :authorization_code_flow_pkce do
          throw("Not found code_verifier")
        else
          form_params
        end
      end

    form_params = Map.to_list(form_params)

    body = {:form, form_params}
    {:ok, response} = HTTPoison.post(client.token_endpoint, body)
    body = Jason.decode!(response.body)

    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_token, body}})

    save_data_to_session(client.cache_pid, body)
    client = update_auth_status(client, :authenticated)
    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_client, client}})

    {conn, client}
  end

  defp do_get_token(_, _) do
    throw("Please provide correct grant_type")
  end

  defp save_data_to_session(pid, token) do
    expires_in = if is_nil(token["expires_in"]), do: 0, else: token["expires_in"]

    GenServer.cast(pid, {:add_kinde_data, {:kinde_login_time_stamp, DateTime.utc_now()}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_access_token, token["access_token"]}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_id_token, token["id_token"]}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_expires_in, expires_in}})

    payload = Utils.parse_jwt(token["id_token"])

    if !is_nil(payload) do
      user = %{
        id: payload["sub"],
        given_name: payload["given_name"],
        family_name: payload["family_name"],
        email: payload["email"]
      }

      GenServer.cast(pid, {:add_kinde_data, {:kinde_user, user}})
    else
      GenServer.cast(pid, {:add_kinde_data, {:kinde_user, nil}})
    end
  end

  @doc """
  Returns the user details after successful authentication.

  ### Usage
        KindeClientSDK.get_user_detail(conn)

  Returns `nil` if not authenticated or if grant type is `:client_credentials`.
  """
  @spec get_user_detail(Plug.Conn.t()) :: any
  def get_user_detail(conn) do
    pid = Conn.get_session(conn, :kinde_cache_pid)

    case GenServer.call(pid, {:get_kinde_data, :kinde_user}) do
      nil -> nil
      [kinde_user: user] -> user
    end
  end

  @doc """
  Log outs your client. Returned `conn` redirects to you to Kinde logout page and
  returns back to your logout redirect url.

  ### Usage
        conn = KindeClientSDK.logout(conn)
  """
  @spec logout(Plug.Conn.t()) :: Plug.Conn.t()
  def logout(conn) do
    pid = Conn.get_session(conn, :kinde_cache_pid)
    [kinde_client: client] = GenServer.call(pid, {:get_kinde_data, :kinde_client})

    clean_session(pid)
    client = update_auth_status(client, :unauthenticated)
    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_client, client}})

    search_params = %{redirect: client.logout_redirect_uri}

    query_params = URI.encode_query(search_params)

    conn =
      conn
      |> Plug.Conn.resp(:found, "")
      |> Plug.Conn.put_resp_header("location", "#{client.logout_endpoint}?#{query_params}")

    conn
  end

  @doc """
  Returns new grant type. Used by `get_token` function.
  """
  @spec get_grant_type(:authorization_code | :authorization_code_flow_pkce | :client_credentials) ::
          :authorization_code | :client_credentials
  def get_grant_type(type) do
    case type do
      :client_credentials ->
        :client_credentials

      :authorization_code ->
        :authorization_code

      :authorization_code_flow_pkce ->
        :authorization_code

      _ ->
        throw("Please provide correct grant_type")
    end
  end

  @doc """
  Returns whether if a user is logged in by verifying that the access token is still valid.

  ### Usage
        KindeClientSDK.authenticated?(conn)
  """
  @spec authenticated?(Plug.Conn.t()) :: boolean
  def authenticated?(conn) do
    pid = Conn.get_session(conn, :kinde_cache_pid)

    timestamp = GenServer.call(pid, {:get_kinde_data, :kinde_login_time_stamp})

    expires_in = GenServer.call(pid, {:get_kinde_data, :kinde_expires_in})

    if [kinde_login_time_stamp: nil] == timestamp or [kinde_expires_in: nil] == expires_in do
      false
    else
      [kinde_login_time_stamp: timestamp] = timestamp
      [kinde_expires_in: expires_in] = expires_in
      DateTime.diff(DateTime.utc_now(), timestamp) < expires_in
    end
  end

  @doc """
  Returns token claims and their value.

  ### Usage

  Second argument defaults to `:access_token`

        KindeClientSDK.get_claims(conn)

  If used with `:id_token`

        KindeClientSDK.get_claims(conn, :id_token)
  """
  @spec get_claims(Plug.Conn.t(), any) :: any
  def get_claims(conn, token_type \\ :access_token) do
    if !(token_type in [:access_token, :id_token]) do
      throw("Please provide valid token (access_token or id_token) to get claim")
    end

    key = String.to_atom("kinde_#{token_type}")

    pid = Conn.get_session(conn, :kinde_cache_pid)

    token =
      case GenServer.call(pid, {:get_kinde_data, key}) do
        [kinde_access_token: data] -> data
        [kinde_id_token: data] -> data
        _ -> nil
      end

    if is_nil(token) do
      throw("Request is missing required authentication credential")
    end

    Utils.parse_jwt(token)
  end

  @doc """
  Returns a single claim from token and its value.

  ### Usage

  Third argument defaults to `:access_token`

        KindeClientSDK.get_claim(conn, "jti")

  If used with `:id_token`

        KindeClientSDK.get_claim(conn, "jti", :id_token)
  """
  @spec get_claim(Plug.Conn.t(), any, any) :: any
  def get_claim(conn, key, token_type \\ :access_token) do
    data = get_claims(conn, token_type)
    data[key]
  end

  @doc """
  Returns an object with a list of permissions and also the relevant org code.

  ### Usage

        KindeClientSDK.get_permissions(conn)
  """
  @spec get_permissions(Plug.Conn.t()) :: %{org_code: any, permissions: any}
  def get_permissions(conn) do
    claims = get_claims(conn)
    %{org_code: claims["org_code"], permissions: claims["permissions"]}
  end

  @doc """
  Given a permission value, returns if it is granted or not and relevant org code.

  ### Usage

        KindeClientSDK.get_permission(conn, "create:users")
  """
  @spec get_permission(Plug.Conn.t(), any) :: %{is_granted: boolean, org_code: any}
  def get_permission(conn, permission) do
    all_claims = get_claims(conn)
    permissions = all_claims["permissions"]
    %{org_code: all_claims["org_code"], is_granted: permission in permissions}
  end

  @doc """
  Returns the org code from the claims.

  ### Usage
        KindeClientSDK.get_user_organization(conn)
  """
  @spec get_organization(Plug.Conn.t()) :: %{org_code: any}
  def get_organization(conn) do
    %{org_code: get_claim(conn, "org_code")}
  end

  @doc """
  Returns the org code from the user token.

  ### Usage
        KindeClientSDK.get_user_organizations(conn)
  """
  @spec get_user_organizations(Plug.Conn.t()) :: %{org_codes: any}
  def get_user_organizations(conn) do
    %{org_codes: get_claim(conn, "org_codes", :id_token)}
  end

  @doc """
  Returns the authentication status.

  ### Usage
        KindeClientSDK.get_auth_status(conn)
  """
  @spec get_auth_status(Plug.Conn.t()) :: any
  def get_auth_status(conn) do
    Conn.get_session(conn, :kinde_auth_status)
  end

  defp update_auth_status(client, status) do
    GenServer.cast(client.cache_pid, {:add_kinde_data, {:kinde_auth_status, status}})
    %{client | auth_status: status}
  end

  defp clean_session(pid) do
    GenServer.cast(pid, {:add_kinde_data, {:kinde_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_access_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_id_token, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_auth_status, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_oauth_state, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_oauth_code_verifier, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_expires_in, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_login_time_stamp, nil}})
    GenServer.cast(pid, {:add_kinde_data, {:kinde_user, nil}})
  end

  defp check_state_authentication(pid, server_state) do
    [kinde_oauth_state: oauth_state] = GenServer.call(pid, {:get_kinde_data, :kinde_oauth_state})

    if is_nil(oauth_state) or server_state != oauth_state do
      throw("Authentication failed because it tries to validate state")
    end
  end
end
